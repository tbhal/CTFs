# LockPick 1

### Phase 1: Getting to know about the things provided
- The challenge provides us with a zip which when extracted contains the following things
```sh
bescrypt.zip  DANGER.txt  forela-criticaldata
```
- After reading the DANGER.txt is there so that we perform our analysis in an isolated machine, from this file we get the password for extracting the bescrypt.zip.
- After extracting we get an ELF 64-bit LSB pie executable.
```sh
file bescrypt3.2                                                                                              
bescrypt3.2: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2b6eafade391d7be39a8aff0d2e3a60aa8b6a4c2, for GNU/Linux 3.2.0, not stripped
```
- After examining the forela-criticaldata we get to know that this folder contains all the encrypted files, this information is displayed when we try reading the text files present in dir.
```sh
ls forela-criticaldata 
co2_London                               it_assets.xml.24bes
complaints.csv.24bes                     it_assets.xml.24bes_note.txt
complaints.csv.24bes_note.txt            sales_forecast.xlsx.24bes
customer-feedback.json.24bes             sales_forecast.xlsx.24bes_note.txt
customer-feedback.json.24bes_note.txt    trading-firebase_bkup.json.24bes
forela_uk_applicants.sql.24bes           trading-firebase_bkup.json.24bes_note.txt
forela_uk_applicants.sql.24bes_note.txt

cat forela-criticaldata/customer-feedback.json.24bes_note.txt 
This file has been encrypted by bes24 group, please contact us at bes24@protonmail.com to discuss payment for us providing you the decryption software..
```
- Our task to open these files, being encrypted with some sort of algorithm so first we have to find the encryption key for this.

### Phase 2: Analyzing the binary
- For this purpose we can use any tool that can help us to static analysis on the binary, I used Radare2 and Binary Ninja.
```sh
[0x00001160]> s main
[0x00001746]> pdf
            ; DATA XREF from entry0 @ 0x1174
┌ 56: int main (int argc, char **argv, char **envp);
│           ; var char *var_10h @ rbp-0x10
│           ; var char *var_8h @ rbp-0x8
│           0x00001746      55             push rbp
│           0x00001747      4889e5         mov rbp, rsp
│           0x0000174a      4883ec10       sub rsp, 0x10
│           0x0000174e      488d05280a00.  lea rax, str.bhUlIshutrea98liOp ; 0x217d ; "bhUlIshutrea98liOp"
│           0x00001755      488945f8       mov qword [var_8h], rax
│           0x00001759      488d05300a00.  lea rax, str._forela_criticaldata_ ; 0x2190 ; "/forela-criticaldata/"
│           0x00001760      488945f0       mov qword [var_10h], rax
│           0x00001764      488b55f8       mov rdx, qword [var_8h]
│           0x00001768      488b45f0       mov rax, qword [var_10h]
│           0x0000176c      4889d6         mov rsi, rdx                ; int64_t arg2
│           0x0000176f      4889c7         mov rdi, rax                ; char *arg1
│           0x00001772      e85dfdffff     call sym.process_directory
│           0x00001777      b800000000     mov eax, 0
│           0x0000177c      c9             leave
└           0x0000177d      c3             ret
```
- After loading and analyzing the binary we can seek to the main function and then use pdf to seet he disassembled function.
- This looks like the key whose address is being stored in rax.
- Now for getting a little better view of the functions that is being used in the code we are going to look at the C Pseudo code that is disassembled by Binary Ninja.
- While navigating through the code we can see that there are functions like process_directory and encrypt_files. The process_directory function takes the directory '/forela-criticaldata' and the key 'bhUlIshutrea98liOp' as input.
``` c
00001249  int64_t encrypt_file(int64_t arg1, int64_t arg2)

00001249  {
00001279      int64_t rax_1 = fopen(arg1, &data_2008, &data_2008);
00001287      int32_t rax_4;
00001287      if (rax_1 == 0)
00001287      {
000012a2          rax_4 = printf("Error opening file: %s\n", arg1);
00001287      }
00001287      else
00001287      {
000012bd          fseek(rax_1, 0, 2);
000012c9          int64_t rax_7 = ftell(rax_1);
000012d9          rewind(rax_1);
000012e5          void* rax_10 = malloc(rax_7);
00001302          fread(rax_10, 1, rax_7, rax_1);
0000130e          fclose(rax_1);
00001383          for (int64_t i = 0; i < rax_7; i = (i + 1))
00001383          {
00001374              *(uint8_t*)((char*)rax_10 + i) = (*(uint8_t*)((char*)rax_10 + i) ^ *(uint8_t*)(arg2 + (COMBINE(0, i) % strlen(arg2))));
00001383          }
000013aa          void var_448;
000013aa          snprintf(&var_448, 0x400, "%s.24bes", arg1);
000013c3          int64_t rax_26 = fopen(&var_448, &data_202c, &data_202c);
000013e0          fwrite(rax_10, 1, rax_7, rax_26);
000013ec          fclose(rax_26);
000013f8          free(rax_10);
00001422          void var_848;
00001422          snprintf(&var_848, 0x400, "%s_note.txt", &var_448);
0000143b          int64_t rax_31 = fopen(&var_848, &data_203b, &data_203b);
00001449          if (rax_31 == 0)
00001449          {
00001492              printf("Error creating note file: %s\n", &var_848);
00001449          }
00001449          else
00001449          {
00001466              fwrite("This file has been encrypted by …", 1, 0x99, rax_31);
00001472              fclose(rax_31);
00001449          }
000014a1          rax_4 = remove(arg1);
000014a8          if (rax_4 != 0)
000014a8          {
000014c3              rax_4 = printf("Error deleting original file: %s…", arg1);
000014a8          }
00001287      }
000014d3      return rax_4;
00001249  }

```

- What exactly is happening in the **encrypt_file** code
    - At first the program tries to open the folder location which has been passed to it as argument.
    - The program then calculates the size of file and allocates memory using malloc and stores it in a pointer.
    - After that it uses a loop to encrypt the data using the second argument that was passed to it.
    - The program then saves the content in a new file which is opened with 'wb' access, and keeps the extension of that file as .24bes
    - After this another file is created which is a note file which have a message and the original files are removed then using remove function.

### Phase 3: Decryption of files
- Now that we understand the logic behind the encryption we have to write a program to decrypt the files, good thing is we have both the logic as well as the key used for encrypting the files.
- Running the decryption code file.
```sh
python3 decrypt-bes.py     
[+] 17% Decryption complete: /home/kali/ctf/forela-criticaldata/decryted_files/it_assets.xml
[+] 33% Decryption complete: /home/kali/ctf/forela-criticaldata/decryted_files/forela_uk_applicants.sql
[+] 50% Decryption complete: /home/kali/ctf/forela-criticaldata/decryted_files/complaints.csv
[+] 67% Decryption complete: /home/kali/ctf/forela-criticaldata/decryted_files/sales_forecast.xlsx
[+] 83% Decryption complete: /home/kali/ctf/forela-criticaldata/decryted_files/customer-feedback.json
[+] 100%
 Decryption Complete.
```
### Answering the questions asked
- Question 1: In the main function
- Question 2: `strings forela_uk_applicants.sql | grep 'wbevansn'`
- Question 3: For this look inside the it_assets.xml file.
- Question 4: This information we can find in the notes file that is present for every encrypted file in the main folder.
- Question 5: Steps for answering this question
    - Load the trading-firebase_bjup.json file.
    - Sort the data in reverse order with key being profit_percentage
    - check the information of the top person
    ```python
        import json
        with open("trading-firebase_bkup.json, 'r') as fb:
            data = json.load(fb)
        data_sort = sorted(data.items(), key=lambda x:x[1]["profit_percentage"], reverse=True)
        highest_person = data_sort[0][1]
    ```
- Question 6: For this question we have to look inside the sales_forecast.xslx file.
- Question 7: This information we can get using analyzing the process_directory code
```c
if (strstr(rax_43 + 0x13, ".txt", ".txt") == 0 && strstr(rax_43 + 0x13, ".sql", ".sql") == 0 && strstr(rax_43 + 0x13, ".pdf", ".pdf") == 0 && strstr(rax_43 + 0x13, ".docx", ".docx") == 0 && strstr(rax_43 + 0x13, ".xlsx", ".xlsx") == 0 && strstr(rax_43 + 0x13, ".csv", ".csv") == 0 && strstr(rax_43 + 0x13, ".json", ".json") == 0 && strstr(rax_43 + 0x13, ".xml", ".xml") == 0)
```
- Question 8: `md5sum forela_uk_applicants.sql`
- Question 9: `md5sum trading-firebase_bkup.json`
- Question 10: `md5sum complaints.csv`

PS: I have used help available online for solving the challenge.
