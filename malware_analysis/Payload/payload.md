# Payload

## Challenge Description
You’ve completed Training Day — congrats, rookie. Now the real game begins. An unmarked binary just landed on your desk. It’s acting shady, tripping a few alarms, but no one's sure what it really is. Malware? Or just a misunderstood piece of code? Your mission: reverse-engineer the program, trace its behavior, and uncover the truth. Every line of code could be a clue—or a trap. Welcome to your first real case.

### Files provided to us
- We have a zip file which contains two files one a txt file which contians the general precautionary data as well as the password for unpacking the other zip file
- Once we unzip we get the an exe file which is our target malware

## Static Analysis
- We'll start by performing static analysis, this will include getting information based on the hash of the malware, running basic programs like string or floss on the given binary and analyzing the headers and imports using PEStudio.

```sh
sha256sum.exe func_pointer.exe
edd41b4a819f917f81203424730aaf0c24cc95e40acfc0f1bd90b11dadf58015
```
- When searching based on the above signature on Virus total we get to see that this can be a Trojan.
![virus-total](/malware_analysis/Payload/poc_images/virus-total-res.png)
- Let's run strings on the binary and see if there is something that we can get from there
```sh
strings.exe func_pointer.exe > strings_Res

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com
```
- From the results we can see that this binary uses many Windows API for execution purpose and apart from that we can see which compiler was used.
```
libgcc_s_dw2-1.dll
__register_frame_info
__deregister_frame_info
kernel32.dll
CreateToolhelp32Snapshot
Process32First
CloseHandle
lstrcmpiA
Process32Next
VirtualAllocEx
WriteProcessMemory
CreateRemoteThread
WaitForSingleObject
explorer.exe
OpenProcess
Argument domain error (DOMAIN)
Argument singularity (SIGN)
Overflow range error (OVERFLOW)
Partial loss of significance (PLOSS)
Total loss of significance (TLOSS)
The result is too small to be represented (UNDERFLOW)
Unknown error
_matherr(): %s in %s(%g, %g)  (retval=%g)
Mingw-w64 runtime failure:
SNIP
%d bit pseudo relocation at %p out of range, targeting %p, yielding the value %p.
runtime error %d
GCC: (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 12.2.0
GCC: (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 12.2.0
SNIP
DeleteCriticalSection
EnterCriticalSection
FreeLibrary
GetLastError
GetModuleHandleA
GetProcAddress
GetStartupInfoA
InitializeCriticalSection
LeaveCriticalSection
LoadLibraryA
SetUnhandledExceptionFilter
Sleep
TlsGetValue
VirtualProtect
VirtualQuery
```
- The **mingw-w64** project is a complete **runtime** environment for gcc to support binaries **native to Windows 64-bit and 32-bit** operating systems.
- Going to PeStudio for checking information related with the indicators, imports and other metadata.
- Here we can see that PeStudio was able to identify multiple things including the entry point, the compiler timestamp and most important the indicators.
![pe_studio_1](/malware_analysis/Payload/poc_images/pe_studio_1.png)
![pe_studio_2](/malware_analysis/Payload/poc_images/pe_studio_2.png)
![pe_studio_3](/malware_analysis/Payload/poc_images/pe_studio_3.png)

- VirtualProtect, changes the protection options (i.e. the way application is allowed to access the memory) of some memory region already allocated with VirtualAllocate or other memory functions. There are many protection options available - readonly, readwrite, execute, all of them etc.

## Basic Dynamic Analysis
- For Dynamic analysis we are going to see the interaction of the malware with the machine.
- This will be done by running monitoring tools like procmon, processhacker, regshot etc.
- We take a snapshot with regshot before running an after running the malware.
- Before executing the malware we know the name of the exe so we can set a filter in procmon so that we can see the response based on that.
- Once we run the malware we see that a cmd window pops behind and then we see that it closes and then we see a small window message.

![run_mal](/malware_analysis/Payload/poc_images/response_while_running_malware.png)\
This windows is being launched under the explorer which directly doesn't allows us to check the memory. This might not even contain much in the memory itself.


- The following is the response when we set a filter in procmon.
![proc_1](/malware_analysis/Payload/poc_images/proc_mon_1.png)

- From this image we can see that the process id is 4712, so from here we can set this as parent process id and see which things were launched from this.
![proc_2](/malware_analysis/Payload/poc_images/proc_mon_2.png)

- Now the same thing we can do with this one as well, but that doesn't leads to anything.

- When checking for the response between regshot images we can see that there are keys that were added and deleted when this malware was executed.\
There were some which intially sparked some concerns but when checked it was nothing that important.


## Advanced Static Analysis
- Here we are going to use disassmeblers and decompilers so that we can analyze the binary.
- Here I have used ghidra which gives us a pseudo code to analyze along with the assembly as well.
- One of the question asks us about the function which are not present in the import table but have been used.
- This sort of functionality in code is achieved using either **LoadLibrary** or **GetProcAddress** method.
- When searched for the same in the code we can see the following results.\
![GetProcAddress](/malware_analysis/Payload/poc_images/GetProcAddress.png)

- In the above snippet we can see 
    - that the code dynamically resolved the Widnows API fucntion using kernel32.dll
    - functions like VirtualAllocEx, CreateRemoteThread
    - then it allocates memory inside another process using VirtualAllocEx
    - then it writes the payload into the allocated memory using WriteProcessMemory.\
    This is a typical code injection behavior.

- After spending some time with the psuode c code that we get, made some changes so that it's easy to identify which function we are dealing. The results are as follows
![main](/malware_analysis/Payload/poc_images/main_binary_nin.png)

![process_injection](/malware_analysis/Payload/poc_images/process_injection_binary_nin.png)

![enum_run_proc](/malware_analysis/Payload/poc_images/process_enum_binary_nin.png)

![decryption](/malware_analysis/Payload/poc_images/decryption_mech.png)

- From the above main function we can see that the decryption mechanism is being supplied with 4 inputs, When we follow the third one in the data section that looks like an encrypted payload

![enc_payload](/malware_analysis/Payload/poc_images/encrypted_payload.png)

- We can take the first 8 bytes of the same and submit as res for task 7.
- We have to examine the decryption logic for getting more insight on what's happening.\
We can see that the call to the decryption logic is having 4 arguments which are
```
arg1 = "UUUUUUUU" # this might be some dummy value
arg2 = var_3c # can be the key length, having value of 8
arg3 = &data_140004040 # encrypted payload
arg4 = var_40 # might be a pointer to key, current value 0x150
```
- But looking at the value the `0x150` doesn't seems like a pointer it looks like the size of the payload that we are supplying.
- Now the only thing left with is the `arg1` it has to be the key which is being supplied.\
Updated take on the arguments
```
arg1 = "UUUUUUUU" The key, U is 55 in hex
arg2 = var_3c # can be the key length, having value of 8
arg3 = &data_140004040 # encrypted payload
arg4 = var_40 # length of the payload 0x150 here
```

## Advanced Dynamic Analysis
Here we'll debug the given binary, I'm using WinDbg / Binary Ninja.

- Under main we can see that process_injection function is being called. this is having the following arguments `rax_9, &var_98 - 0x120, var_40`.\
One question asks us what is the address of the decrypted payload. This we can get from here. As per the general program structure when the injection is supposed to happen, it will contain the address for the decrypted payload that it's supposed to execute.\
This we can confirm that it's the second argument in the call.

- So here we have to debug and see what is the content of the stack during the function call. We'll add a breakpoint and analyze.\
As the arguments are loaded from right to left for a function, our target here will be the second mov instruction which changes the rdx register, which we believe is the address to our decrypted payload.
![function](/malware_analysis/Payload/poc_images/register_val.png)

- Once we have this address then we can go there and check what is present in the memory and get our decrypted payload
![decrypted](/malware_analysis/Payload/poc_images/decrypted_payload.png)

### Challenge Complete
