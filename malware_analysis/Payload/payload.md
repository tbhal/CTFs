# Payload

## Challenge Description
You’ve completed Training Day — congrats, rookie. Now the real game begins. An unmarked binary just landed on your desk. It’s acting shady, tripping a few alarms, but no one's sure what it really is. Malware? Or just a misunderstood piece of code? Your mission: reverse-engineer the program, trace its behavior, and uncover the truth. Every line of code could be a clue—or a trap. Welcome to your first real case.

### Files provided to us
- We have a zip file which contains two files one a txt file which contians the general precautionary data as well as the password for unpacking the other zip file
- Once we unzip we get the an exe file which is our target malware

## Static Analysis
- We'll start by performing static analysis, this will include getting information based on the hash of the malware, running basic programs like string or floss on the given binary and analyzing the headers and imports using PEStudio.

```sh
sha256sum.exe func_pointer.exe
edd41b4a819f917f81203424730aaf0c24cc95e40acfc0f1bd90b11dadf58015
```
- When searching based on the above signature on Virus total we get to see that this can be a Trojan.
![virus-total](virus-total-res.png)
- Let's run strings on the binary and see if there is something that we can get from there
```sh
strings.exe func_pointer.exe > strings_Res

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com
```
- From the results we can see that this binary uses many Windows API for execution purpose and apart from that we can see which compiler was used.
```
libgcc_s_dw2-1.dll
__register_frame_info
__deregister_frame_info
kernel32.dll
CreateToolhelp32Snapshot
Process32First
CloseHandle
lstrcmpiA
Process32Next
VirtualAllocEx
WriteProcessMemory
CreateRemoteThread
WaitForSingleObject
explorer.exe
OpenProcess
Argument domain error (DOMAIN)
Argument singularity (SIGN)
Overflow range error (OVERFLOW)
Partial loss of significance (PLOSS)
Total loss of significance (TLOSS)
The result is too small to be represented (UNDERFLOW)
Unknown error
_matherr(): %s in %s(%g, %g)  (retval=%g)
Mingw-w64 runtime failure:
SNIP
%d bit pseudo relocation at %p out of range, targeting %p, yielding the value %p.
runtime error %d
GCC: (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 12.2.0
GCC: (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 12.2.0
SNIP
DeleteCriticalSection
EnterCriticalSection
FreeLibrary
GetLastError
GetModuleHandleA
GetProcAddress
GetStartupInfoA
InitializeCriticalSection
LeaveCriticalSection
LoadLibraryA
SetUnhandledExceptionFilter
Sleep
TlsGetValue
VirtualProtect
VirtualQuery
```
- The **mingw-w64** project is a complete **runtime** environment for gcc to support binaries **native to Windows 64-bit and 32-bit** operating systems.
- Going to PeStudio for checking information related with the indicators, imports and other metadata.
- Here we can see that PeStudio was able to identify multiple things including the entry point, the compiler timestamp and most important the indicators.
![pe_studio_1](pe_studio_1.png)
![pe_studio_2](pe_studio_2.png)
![pe_studio_3](pe_studio_3.png)

- VirtualProtect, changes the protection options (i.e. the way application is allowed to access the memory) of some memory region already allocated with VirtualAllocate or other memory functions. There are many protection options available - readonly, readwrite, execute, all of them etc.

## Basic Dynamic Analysis
- For Dynamic analysis we are going to see the interaction of the malware with the machine.
- This will be done by running monitoring tools like procmon, processhacker, regshot etc.
- We take a snapshot with regshot before running an after running the malware.
- Before executing the malware we know the name of the exe so we can set a filter in procmon so that we can see the response based on that.
- Once we run the malware we see that a cmd window pops behind and then we see that it closes and then we see a small window message.

![run_mal](response_while_running_malware.png)\
This windows is being launched under the explorer which directly doesn't allows us to check the memory. This might not even contain much in the memory itself.


- The following is the response when we set a filter in procmon.
![proc_1](proc_mon_1.png)

- From this image we can see that the process id is 4712, so from here we can set this as parent process id and see which things were launched from this.
![proc_2](proc_mon_2.png)

- Now the same thing we can do with this one as well, but that doesn't leads to anything.

- When checking for the response between regshot images we can see that there are keys that were added and deleted when this malware was executed.\
There were some which intially sparked some concerns but when checked it was nothing that important.


## Advanced Static Analysis
- Here we are going to use disassmeblers and decompilers so that we can analyze the binary.
- Here I have used ghidra which gives us a pseudo code to analyze along with the assembly as well.
- One of the question asks us about the function which are not present in the import table but have been used.
- This sort of functionality in code is achieved using either **LoadLibrary** or **GetProcAddress** method.
- When searched for the same in the code we can see the following results.\
![GetProcAddress](GetProcAddress.png)

- In the above snippet we can see 
    - that the code dynamically resolved the Widnows API fucntion using kernel32.dll
    - functions like VirtualAllocEx, CreateRemoteThread
    - then it allocates memory inside another process using VirtualAllocEx
    - then it writes the payload into the allocated memory using WriteProcessMemory.\
    This is a typical code injection behavior.

Work in progress
